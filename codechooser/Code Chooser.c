#pragma config(Sensor, in4,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in5,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in6,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in7,    lightSensor,    sensorReflection)
#pragma config(Sensor, in8,    petentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  frontTouch,     sensorTouch)
#pragma config(Sensor, dgtl4,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  clawTouch,      sensorTouch)
#pragma config(Motor,  port2,           leftMotor,     tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port3,           rightMotor,    tmotorVex269, openLoop)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex269, openLoop)
#pragma config(Motor,  port7,           armMotor,      tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

/*
Code Chooser
ROBOTC on VEX 2.0 Cortex

This program uses the Display functions of ROBOTC on the VEX 2.0 Cortex platform.
It allows the user to choose from 4 different pieces of code using the left and right buttons
on the VEX LCD. Once the center button is pressed, the code corresponding with the choice is run.
This code can be adapted for competition based settings - just place the code for the first
switch case in the pre_auton function, and the code for the second switch in the autonomous task.
Replace the basic movement behaviors in the second switch with your own autonomous routines.

ROBOT CONFIGURATION
MOTORS & SENSORS:
[I/O Port]					[Name]							[Type]								[Description]
UART Port 2					none								VEX LCD								VEX LCD Screen
Motor Port 2				rightMotor					VEX 3-wire module			Right side motor
Motor Port 3				leftMotor						VEX 3-wire module			Left side motor
*/

#include "../includes/headers/myheader.h"
#include "../includes/functions/motorFunctions.inc"


const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

task main()
{
	StartTask(stopRobot);
	//Declare count variable to keep track of our choice
	int count = 0;

	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Assignment 2b");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Autonomous 2c");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Autonomous 3a");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Autonomous 4");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
	//------------- End of User Interface Code ---------------------

	//------------- Beginning of Robot Movement Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Assignment 2b");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds
		int counter;

		for(counter = 1; counter <= 5; counter++){
				resetEncoder();
				driveEncoder(BASEDIST*counter, true);
				resetEncoder();
				driveEncoder(BASEDIST*counter, false);
				resetEncoder();
		}

		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Assignment 2c");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds
		bool turnArray[14]={0,1,1,0,0,1,0,0,1,0,0,1,1,0};
		for(int i=0;i<15;i++){
			stopMotors();
			resetEncoder();
			driveEncoder(BASEDIST, true);
			stopMotors();
			resetEncoder();
			turn(BASETURN, turnArray[i]);
		}
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Autonomous 3a");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds
		while(1 == 1) {
				motor[leftMotor]  = (vexRT[Ch3] + vexRT[Ch4])/2;
				motor[rightMotor] = (vexRT[Ch3] - vexRT[Ch4])/2;

				if(vexRT[Btn5U] == 1)	{
					motor[armMotor] = 127;
				}
				else if(vexRT[Btn5D] == 1) {
					motor[armMotor] = -127;
				}
				else {
					motor[armMotor] = 0;
				}

				if(vexRT[Btn6U] == 1)	{
					motor[clawMotor] = 127;
				}
				else if(vexRT[Btn6D] == 1) {
					motor[clawMotor] = -127;
				}
				else {
					motor[clawMotor] = 0;
				}
		}
		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Autonomous 4");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds
		while(1 == 1) {
					while(SensorValue(sonar) > 60  || SensorValue(sonar) == -1)
					{
						motor[rightMotor] = 63;
						motor[leftMotor]  = 63;
						light();
					}
					stopMotors();
					turn(BASETURN, random(2)-1);
					stopMotors();
					light();
				}
		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
	//------------- End of Robot Movement Code -----------------------
}
